from math import gcd
from base64 import b64decode
from gmpy2 import invert
from Crypto.PublicKey import RSA

a = 84733215803103612460901465701232424798609470209825913961212238457798293111098195061837071495218083197429913141798442522950831495758395873695688189182925448736211066067276791533151828542439575601763801135131479532656528730453020404557236783254278625529895480234633323403399468237577058553920576024305830379725
assert a == 5 * 5 * 3389328632124144498436058628049296991944378808393036558448489538311931724443927802473482859808723327897196525671937700918033259830335834947827527567317017949448442642691071661326073141697583024070552045405259181306261149218120816182289471330171145021195819209385332936135978729503082342156823040972233215189
r = 21700996784810065805847020455080940987640304282783092123992896363328128691169420271855815648912121417792054646557156071514079520782530801688062034321252682229729442734741486715339008457753023855600772948737800521010217600436912058582658334252483984244806083617513596479033871117464319239681526924092910597300
r_half = 2 * 5 * 5 * 7 * 13 * 79 * 431 * 32109367 * 123195211 * 17705506663292483050486705300006531780530522718952926487466209230346074066094643263236467795541941630007824443819915896963225571073508859266219151247127605202725798350124908623365852262492575404456499807872919943733294999610388836394731275545745140970652134809966632766294286289046331
assert r == 2 * r_half
# a^r â‰¡ 1 (mod n)

c = 85407181759755287105309527383534372436668736072315927293076398182206068631971587183149437554341349819060482477969350837066653250734556920049021810122548703168301872412719117857995283679569989680329696657609285728934732302846152702363240223251805773071022405764521081142920227557091217872210813095318042763847

key64 = 'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC5a2J4gIZo3mzj0LdTFbESkwD+\
tIuiM1Pwl7Z8Aj+9zdDmMIbujHEamxU+osKjEh/BQeJ6fWYucrjDHliQoDFL6Soy\
jti228yQw9fwp13IwTsPQao0d2JTZQ36J9PDgJuBv7EDo1bsJ2G23SM1SaIrqzMi\
QJI0LnAnlkxwqePuywIDAQAB'
key = RSA.importKey(b64decode(key64))

e = key.publickey().e  # 65537
N = key.publickey().n  # big

p = gcd(pow(a, r_half, N) - 1, N)
q = gcd(pow(a, r_half, N) + 1, N)
assert p * q == N
phi = (p - 1) * (q - 1)

d = int( invert(e, phi) )
assert (e*d) % phi == 1


#import Crypto
#modBits = Crypto.Util.number.size(N)
#k = Crypto.Util.number.ceil_div(modBits, 8) # Convert from bits to bytes
#hLen = 128  #self._hashObj.digest_size
#
## Step 2a (O2SIP), 2b (RSADP), and part of 2c (I2OSP)
#m = self._key.decrypt(ct)
#
## Complete step 2c (I2OSP)
#em = bchr(0x00)*(k-len(m)) + m

from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA

cipher = PKCS1_OAEP.new(RSA.construct(
    (N, e, d, p, q)
))

flag = cipher.decrypt( bytes.fromhex(hex(c)[2:]) )
print(flag)
